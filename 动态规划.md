##### 基本概念
动态规划（dynamic programming）是一个重要的算法范式，它将一个问题分解为一系列更小的子问题，并通过存储子问题的解来避免重复计算，从而大幅提升时间效率。
动态规划的常用术语。

- 将数组dp称为dp表，dp[i]表示状态i对应子问题的**解**。
- 将最小子问题对应的状态（第1阶和第2阶楼梯）称为**初始状态**。
- 将递推公式dp[i] = dp[i-1] + dp[i-2]称为**状态转移方程**。

在动态规划问题中，当前状态往往与前面有限个状态有关，这时我们可以只保留必要的状态，通过“降维”来节省内存空间。**这种空间优化技巧被称为“滚动变量”或“滚动数组”**


动态规划常用来求解最优化问题，它们不仅包含重叠子问题，还具有量大特性：**最优子结构、无后效性**

最优子结构：**原问题的最优解是从子问题的最优解构建得来的**
无后效性：**给定一个确定的状态，它的未来发展只与当前状态有关，而与过去的经历的所有状态无关**

##### DP问题解题思路
适合用回溯解决的问题通常满足“决策树模型”
在此基础上，动态规划问题还有一些判断的“加分项”
- 问题包含最大（小）或最多（少）等最优化描述
- 问题的状态能够使用一个列表、多维矩阵或树来表示，并且一个状态与其他状态存在递推关系。
###### 0-1背包问题
给定n个物品，第i个物品的重量为wgt[i-1]、价值为val[i-1] ，和一个容量为cap 的背包。每个物品只能选择一次，问在限定背包容量下能放入物品的最大价值。

###### 编辑距离问题
###### 第一步：思考每轮的决策，定义状态，从而得到dp表
状态[i,j]对应的子问题：**将s的前i个字符更改为t的前j个字符所需的最少编辑步数**
至此，得到一个尺寸为$(i+1)\times(j+1)$的二维dp表.
###### 第二步：找出最优子结构，进而推导出状态转移方程
考虑子问题d[i,j]，其对应的两个字符串的尾部字符串为s[i-1]和t[j-1]，根据不同的编辑操作分为三种情况
1.添加。在s[i-1]之后添加t[j-1]，则剩余子问题dp[i,j-1]
2.删除。删除s[i-1]，则剩余子问题dp[i-1,j]
3.替换。s[i-1]替换为t[j-1]，则剩余子问题dp[i-1,j-1]
则 d[i,j] = min(dp[i,j-1], dp[i-1,j], dp[i-1,j-1]) + 1
如果s[i-1]与t[j-1]相同，无需编辑当前字符，d[i,j] = d[i-1,j-1]
###### 第三步：确定边界条件和状态转移顺序
dp[0,0] = 0,dp[0,j] = j,dp[i,0] = i
