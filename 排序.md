##### 排序算法评价维度

- 运行效率
  我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。
- 就地性
  顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。
- 稳定性
  稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。
- 自适应性
  自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。
- 是否基于比较
  基于比较的排序依赖比较运算符（>、=、<）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $O(nlogn)$

#### 选择排序

开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾
时间复杂度 $O(n^2)$

```
function selectionSort(nums) {
    let n = nums.length;
    // 外循环：未排序区间为 [i, n-1]
    for (let i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j; // 记录最小元素的索引
            }
        }
        // 将该最小元素与未排序区间的首个元素交换
        [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    return nums;
}
```

##### 冒泡排序

通过连续地比较和交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此叫冒泡排序.
时间复杂度 $O(n^2)$

##### 插入排序

1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。
3. 选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。
4. 以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。
   时间复杂度 $O(n^2)$

插入排序的使用频率显著高于冒泡排序和选择排序。

- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，冒泡排序的计算开销通常比插入排序更高。
- 选择排序在任何情况下的时间复杂度都为 $O(n^2)$ 。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。
- 选择排序不稳定，无法应用于多级排序。

##### 快速排序

快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。

###### 哨兵划分

1. 选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。

###### 算法过程

1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组
2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”
3. 持续递归，直至数组长度为 1 时候终止，此时数组排序已完成

##### 归并排序
归并排序是一种基于分治策略的排序算法。包含“划分”和“合并”阶段
1. 划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换成短数组的排序问题。
2. 合并阶段：当子数组长度为1时候终止划分，开始合并，持续将左右两个较短的有序数组合并为一个较长的有序数组
###### 算法流程
1. 计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。
2. 递归执行步骤 1. ，直至子数组区间长度为 1 时终止。
“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。


##### 堆排序
堆排序是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序
###### 算法流程
假设数组的长度为n，
1. 输入数组并建立**大顶堆**，完成建堆后，最大元素位于堆顶。
2. 将堆顶元素与堆底元素交换。完成交换后，堆的长度减1，已排序元素数量加1
3. 从堆顶元素开始执行向下堆化操作。
4. 循环执行2.3步骤。循环n-1轮，即可完成数组排序

##### 桶排序
桶排序是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内分别执行排序；最终按照桶的顺序将所有数据合并。
###### 算法流程
考虑一个长度为n的数组，其元素是范围\[0, 1\)内的浮点数。
1. 初始化k个桶，将n个元素分配到k个桶中。
2. 对每个桶分别执行排序
3. 按照桶从大到小的顺序合并结果
关键点，桶分配规则，桶索引为$\lfloor x*k \rfloor$，如果数字不在0,1，那么数字需要归一化
###### 算法特性
桶排序适用于处理体量很大的数据，例如，输入数据包含100万个元素，由于空间限制，系统内存无法一次性加载所有数据。


##### 计数排序
通过统计元素数量来实现排序，通常应用于整数数组。
计数排序适用于数据量大但数据范围较小的情况


##### 基数排序
通过统计个数来实现排序，在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。
适用于数值范围较大的情况，但前提是数据必须可以表示为固定位数的格式，且位数不能过大。
###### 算法流程
以学号数据为例，假设数字的最低位为第1位，最高位是第8位。
1. 初始化位数 k = 1.
2. 对学号的第k位执行“计数排序”，数据会根据第K位从小到大排序
3. 将k增加1，然后返回步骤2，继续迭代，直到所有位都排序完成结束