##### 排序算法评价维度

- 运行效率
  我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。
- 就地性
  顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。
- 稳定性
  稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。
- 自适应性
  自适应排序能够利用输入数据已有的顺序信息来减少计算量，达到更优的时间效率。
- 是否基于比较
  基于比较的排序依赖比较运算符（>、=、<）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 $O(nlogn)$

#### 选择排序

开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾
时间复杂度 $O(n^2)$

```
function selectionSort(nums) {
    let n = nums.length;
    // 外循环：未排序区间为 [i, n-1]
    for (let i = 0; i < n - 1; i++) {
        // 内循环：找到未排序区间内的最小元素
        let minIndex = i;
        for (let j = i + 1; j < n; j++) {
            if (nums[j] < nums[minIndex]) {
                minIndex = j; // 记录最小元素的索引
            }
        }
        // 将该最小元素与未排序区间的首个元素交换
        [nums[i], nums[minIndex]] = [nums[minIndex], nums[i]];
    }
    return nums;
}
```

##### 冒泡排序

通过连续地比较和交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此叫冒泡排序.
时间复杂度 $O(n^2)$

##### 插入排序

1. 初始状态下，数组的第 1 个元素已完成排序。
2. 选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。
3. 选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。
4. 以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。
   时间复杂度 $O(n^2)$

插入排序的使用频率显著高于冒泡排序和选择排序。

- 冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，冒泡排序的计算开销通常比插入排序更高。
- 选择排序在任何情况下的时间复杂度都为 $O(n^2)$ 。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。
- 选择排序不稳定，无法应用于多级排序。

##### 快速排序

快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。

###### 哨兵划分

1. 选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。
2. 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。
3. 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。

###### 算法过程

1. 首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组
2. 然后，对左子数组和右子数组分别递归执行“哨兵划分”
3. 持续递归，直至数组长度为 1 时候终止，此时数组排序已完成

##### 归并排序
